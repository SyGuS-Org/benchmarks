(set-logic CHC_LIA)

(synth-fun state ((x_0 Bool) (x_1 Bool) (x_2 Bool) (x_3 Bool) (x_4 Int) (x_5 Int)) Bool)

(constraint (forall ((.s.1 Bool) (.s.0 Bool) (.s.2 Bool) (.s.3 Bool) (main.x Int) (main.y Int)) (=> (and (not .s.1) .s.0 (not .s.2) (not .s.3)) (state .s.1 .s.0 .s.2 .s.3 main.x main.y))))
(constraint (forall ((.s.1 Bool) (.s.0 Bool) (.s.2 Bool) (.s.3 Bool) (main.x Int) (main.y Int) (.s.1.next Bool) (.s.0.next Bool) (.s.2.next Bool) (.s.3.next Bool) (main.x.next Int) (main.y.next Int) (.inputVar.0 Int)) (let ((a!1 (and .s.3 (and (and (not .s.1) .s.0) .s.2))) (a!2 (and (and (and (not .s.1.next) .s.0.next) .s.2.next) .s.3.next (= main.x main.x.next) (= main.y main.y.next))) (a!3 (and .s.3 (and .s.2 (and (not .s.1) (not .s.0))))) (a!4 (and (= main.y main.y.next) (= main.x main.x.next) (not .s.3.next) (and (not .s.2.next) (and (not .s.1.next) (not .s.0.next))))) (a!5 (not (and .s.3 (and (not .s.2) (and .s.1 .s.0))))) (a!6 (and (= main.y main.y.next) (= main.x main.x.next) .s.3.next (and .s.2.next (and (not .s.1.next) (not .s.0.next))))) (a!7 (and .s.3 (and (not .s.2) (and .s.1 (not .s.0))))) (a!11 (and (and (and (not .s.1) .s.0) (not .s.2)) .s.3)) (a!12 (and (= main.y main.y.next) (= main.x main.x.next) (not .s.3.next) .s.2.next (and .s.1.next (not .s.0.next)))) (a!13 (and .s.3 (and (not .s.2) (and (not .s.1) (not .s.0))))) (a!14 (= (+ main.y (* (- 1) main.y.next)) 1)) (a!16 (= (+ main.x (* (- 1) main.x.next)) 4)) (a!19 (and (and (not .s.3) .s.2 (and .s.1 (not .s.0))) (<= main.x 0))) (a!20 (and (= main.y main.y.next) (= main.x main.x.next) .s.3.next (and (not .s.2.next) (and .s.1.next (not .s.0.next))))) (a!21 (and (and (not .s.3) .s.2 (and .s.1 (not .s.0))) (not (<= main.x 0)))) (a!22 (and (not .s.3) (and (and (not .s.1) .s.0) .s.2))) (a!23 (and (not .s.3.next) (and (not .s.2.next) (and .s.1.next (not .s.0.next))))) (a!24 (and (not .s.3) (and .s.2 (and (not .s.1) (not .s.0))))) (a!25 (= (+ main.y (* (- 1) main.y.next)) (- 1))) (a!27 (not (and (not .s.3) (and (not .s.2) (and .s.1 .s.0))))) (a!28 (= (+ main.x (* (- 1) main.x.next)) (- 4))) (a!30 (and (not .s.3) (and (not .s.2) (and .s.1 (not .s.0))))) (a!33 (and (and (and (not .s.1) .s.0) (not .s.2)) (not .s.3))) (a!34 (and (not .s.3) (and (not .s.2) (and (not .s.1) (not .s.0)))))) (let ((a!8 (and a!7 (not (<= main.y (- 1))))) (a!10 (not (and a!7 (<= main.y (- 1))))) (a!15 (or (not a!13) (and (= main.x main.x.next) a!14 .s.3.next (and (not .s.1.next) .s.0.next) (not .s.2.next)))) (a!17 (and (= main.y main.y.next) a!16 .s.3.next (and (not .s.2.next) (and (not .s.1.next) (not .s.0.next))))) (a!26 (and (= main.x main.x.next) a!25 (and (and (not .s.1.next) .s.0.next) .s.2.next) (not .s.3.next))) (a!29 (and (= main.y main.y.next) a!28 (not .s.3.next) (and .s.2.next (and (not .s.1.next) (not .s.0.next))))) (a!31 (or (not (and a!30 (= .inputVar.0 0))) (and (= main.y main.y.next) (= main.x main.x.next) (not .s.3.next) (and (not .s.2.next) (and .s.1.next .s.0.next))))) (a!32 (not (and a!30 (not (= .inputVar.0 0)))))) (let ((a!9 (or (not a!8) (and (= main.y main.y.next) (= main.x main.x.next) .s.3.next (and (not .s.2.next) (and .s.1.next .s.0.next))))) (a!18 (or (not (and (not .s.3) .s.2 (and .s.1 .s.0))) a!17))) (let ((a!35 (and (state .s.1 .s.0 .s.2 .s.3 main.x main.y) (or (not a!1) a!2) (or (not a!3) a!4) (or a!5 a!6) a!9 (or a!2 a!10) (or (not a!11) a!12) a!15 a!18 (or (not a!19) a!20) (or (not a!21) (and (= main.y main.y.next) (= main.x main.x.next) (not .s.3.next) .s.2.next (and .s.1.next .s.0.next))) (or (not a!22) (and (= main.y main.y.next) (= main.x main.x.next) a!23)) (or (not a!24) a!26) (or a!27 a!29) a!31 (or a!12 a!32) (or (not a!33) (and (= main.x.next 0) a!23 (= main.y.next 0))) (or a!4 (not a!34))))) (=> a!35 (state .s.1.next .s.0.next .s.2.next .s.3.next main.x.next main.y.next))))))))
(constraint (forall ((.s.1 Bool) (.s.0 Bool) (.s.2 Bool) (.s.3 Bool) (main.x Int) (main.y Int)) (let ((a!1 (not (not (and .s.3 (not .s.1) .s.0 .s.2))))) (=> (and (state .s.1 .s.0 .s.2 .s.3 main.x main.y) a!1) false))))

(check-synth)

